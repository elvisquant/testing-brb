from pydantic import BaseModel, EmailStr, Field, validator, computed_field
from typing import Optional,List
from datetime import datetime, date
import enum # For Python enum
from enum import Enum

###################################################################################################################
# --- Pydantic Schemas for Dashboard Responses ---
# (You might want to put these in your main schemas.py and import them)


#This is to ensure the vehicle is eligible to fuel again
class EligibilityResponse(BaseModel):
    eligible: bool
    message: str


#######################################################################################################################

class KPIStats(BaseModel):
    total_vehicles: int
    planned_trips: int 
    repairs_this_month: int
    fuel_cost_this_week: float


class FuelEfficiencyData(BaseModel):
    current_month_volume: float
    last_month_volume: float
    percentage_change: Optional[float] = None
    trend: Optional[str] = None # "up", "down", "steady", "no_comparison"


class MaintenanceComplianceData(BaseModel):
    total_maintenance_records: int
    # If you want comparison for maintenance:
    # current_month_maintenances: int
    # last_month_maintenances: int

class PerformanceInsightsResponse(BaseModel):
    fuel_efficiency: FuelEfficiencyData
    maintenance_compliance: MaintenanceComplianceData # Renamed for clarity


class AlertItem(BaseModel):
    plate_number: Optional[str] = "N/A"
    message: Optional[str] = "N/A"
    entity_type: str # "panne", "maintenance", "trip"
    status: Optional[str] = "N/A" # Optional: specific status of the alert item

class AlertsResponse(BaseModel):
    critical_panne: Optional[AlertItem] = None
    maintenance_alert: Optional[AlertItem] = None
    trip_alert: Optional[AlertItem] = None
    total_alerts: int = 0


# --- NEW Schemas for Chart Data ---
class MonthlyActivityChartData(BaseModel):
    labels: List[str]
    trips: List[int]
    maintenances: List[int]
    pannes: List[int]


###################################################################################################################
# --- Service Schemas ---

class ServiceBase(BaseModel):
    """
    Base schema for a Service, containing the core fields.
    """
    service_name: str = Field(..., min_length=3, max_length=100, example="Human Resources")

class ServiceCreate(ServiceBase):
    """
    Schema used for creating a new service. Inherits from ServiceBase.
    No additional fields are needed for creation.
    """
    pass

class ServiceUpdate(BaseModel):
    """
    Schema for updating an existing service. All fields are optional.
    """
    service_name: Optional[str] = Field(None, min_length=3, max_length=100, example="IT Department")

class ServiceOut(ServiceBase):
    """
    Schema for representing a service in API responses.
    Includes the 'id' field which is generated by the database.
    """
    id: int = Field(..., example=1)

    class Config:
        from_attributes = True # Pydantic V2+ (replaces orm_mode)

##################################################################################################################
class RoleBase(BaseModel):
    name: str = Field(..., example="driver")
    description: Optional[str] = Field(None, example="Can operate company vehicles")

class RoleCreate(RoleBase):
    pass

class RoleOut(RoleBase):
    id: int
    
    class Config:
        from_attributes = True
###################################################################################################################
# --- User Schemas ---

class UserBase(BaseModel):
    matricule: str = Field(..., max_length=9, example="AB0123BA")
    first_name: str = Field(..., max_length=50, example="John")
    last_name: str = Field(..., max_length=50, example="Doe")
    telephone: str = Field(..., max_length=25, example="+257 79 001 002")
    service_id: int = Field(..., example=1)
    email: EmailStr = Field(..., example="john.doe@gmail.com")
    status: Optional[str] = Field("pending", example="active")

class UserCreate(UserBase):
    password: str = Field(..., min_length=8, description="User password (will be hashed)")
    # --- THIS IS THE KEY CHANGE ---
    # When creating a user, we now pass the ID of the role they should have.
    #role_id: int = Field(..., example=1, description="ID of the user's role")

class UserUpdate(BaseModel):
    # ... (fields for matricule, first_name, etc. remain the same) ...
    matricule: Optional[str] = Field(None, max_length=9)
    first_name: Optional[str] = Field(None, max_length=50)
    last_name: Optional[str] = Field(None, max_length=50)
    telephone: Optional[str] = Field(None, max_length=25)
    service_id: Optional[int] = Field(None)
    email: Optional[EmailStr] = Field(None)
    status: Optional[str] = Field(None)
    
    # When updating a user, we can optionally change their role by providing a new role_id
    role_id: Optional[int] = Field(None, description="New role ID for the user")

class UserOut(UserBase):
    id: int
    created_at: datetime
    # --- THIS IS THE KEY CHANGE ---
    # The 'role' field in the response will be a nested object with the role's details.
    role: RoleOut
    service: Optional[ServiceOut] = None
    
    class Config:
        from_attributes = True


class UserSimpleOut(BaseModel):
    """
    A minimal user representation, useful for nesting in other schemas
    to avoid circular dependencies and sending too much data.
    """
    id: int
    first_name: str
    last_name: str
    matricule: str

    class Config:
        from_attributes = True

# --- Authentication Schemas (Unchanged) ---

class UserLogin(BaseModel):
    identifier: str = Field(..., description="Matricule or email address", example="AB0123BA")
    password: str = Field(..., min_length=8, description="User password")


class Token(BaseModel):
    access_token: str
    token_type: str
    user_id: int
    username: str # This holds the matricule
    status: str
    role: str
    service_id: int 

class TokenData(BaseModel):
    sub: str
    user_id: int
    status: str
    # username: str # This is not standard in 'sub', so it might be redundant
    role: str # Role name

class PasswordChange(BaseModel):
    current_password: str = Field(..., description="User's current password")
    new_password: str = Field(..., min_length=8, description="New desired password")
###################################################################################################################

class DriverBase(BaseModel):
    last_name: str
    first_name: str
    cni_number: str
    email: str
    matricule: str

class DriverCreate(DriverBase):
    pass

class DriverOut(DriverBase):
    id: int
    created_at: datetime

    class Config:
        from_attributes = True


class TopDriver(BaseModel):
    driver_id: int
    first_name: str
    last_name: str
    # profile_image_url: Optional[str] = None # If you store profile images
    performance_metric: str # e.g., "X Trips Completed", "Y% On-Time"
    
    class Config:
        from_attributes = True
##################################################################################################################

class CategoryFuelBase(BaseModel):
    fuel_name: str

class CategoryFuelCreate(CategoryFuelBase):
    pass

class CategoryFuelOut(CategoryFuelBase):
    id: int
    created_at: datetime

    class Config:
        from_attributes = True

##################################################################################################################

class FuelTypeBase(BaseModel):
    fuel_type: str
    # description: Optional[str] = None

class FuelTypeCreate(FuelTypeBase):
    pass

class FuelTypeOut(FuelTypeBase):
    id: int
    # Add any other fields you want to return from the API

    class Config:
        from_attributes = True # or orm_mode = True for older Pydantic
##################################################################################################################

class FuelBase(BaseModel): # Common fields, including those for DB model
    vehicle_id: int
    fuel_type_id: int
    quantity: float
    price_little: float
    cost: float # This will be in the DB model and in responses

class FuelCreatePayload(BaseModel): # Schema for what the CLIENT SENDS on POST
    vehicle_id: int
    fuel_type_id: int
    quantity: float
    price_little: float
    # 'cost' is intentionally omitted here

class FuelUpdatePayload(BaseModel): # Schema for what the CLIENT SENDS on PUT (partial updates)
    vehicle_id: Optional[int] = None
    fuel_type_id: Optional[int] = None
    quantity: Optional[float] = None
    price_little: Optional[float] = None
    # 'cost' is omitted, will be recalculated if quantity or price_little changes
    # If you want to allow manual override of cost on update, add: cost: Optional[float] = None

class FuelOut(FuelBase): # Schema for API RESPONSES
    id: int
    created_at: datetime

    class Config:
        from_attributes = True
##################################################################################################################
# --- Trip Schemas ---

class TripBase(BaseModel):
    vehicle_id: int
    driver_id: int
    start_location: str
    end_location: str
    start_time: datetime
    end_time: Optional[datetime] = None
    status: str = "planned"
    # --- NEW OPTIONAL FIELDS ---
    purpose: Optional[str] = None
    notes: Optional[str] = None
    # --- END NEW OPTIONAL FIELDS ---

class TripCreate(TripBase):
    pass # Inherits all from TripBase, including new fields

class TripUpdate(BaseModel): # For PUT, allow partial updates
    vehicle_id: Optional[int] = None
    driver_id: Optional[int] = None
    start_location: Optional[str] = None
    end_location: Optional[str] = None
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None
    status: Optional[str] = None
    # --- NEW OPTIONAL FIELDS ---
    purpose: Optional[str] = None
    notes: Optional[str] = None
    # --- END NEW OPTIONAL FIELDS ---


class VehicleStatusChartData(BaseModel):
    labels: List[str]
    counts: List[int]



######             ############### ######################


class VehicleNestedInTrip(BaseModel):
    id: int
    plate_number: Optional[str] = None

    # This computed field logic seems complex and might be better handled in the router.
    # For Pydantic to work directly, the ORM object needs 'make_ref' and 'model_ref'.
    @computed_field(return_type=Optional[str])
    @property
    def make(self) -> Optional[str]:
            if hasattr(self, 'make_ref') and self.make_ref and hasattr(self.make_ref, 'vehicle_make'):
                return self.make_ref.vehicle_make
            return None

    @computed_field(return_type=Optional[str])
    @property
    def model(self) -> Optional[str]:
            if hasattr(self, 'model_ref') and self.model_ref and hasattr(self.model_ref, 'vehicle_model'):
                return self.model_ref.vehicle_model
            return None
    
    class Config:
        from_attributes = True

class DriverNestedInTrip(BaseModel): # If you also load driver
    id: int
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    class Config: 
        from_attributes = True

class TripResponse(TripBase):
    id: int
    created_at: Optional[datetime] = None 
    updated_at: Optional[datetime] = None
    vehicle: Optional[VehicleNestedInTrip] = None   
    driver: Optional[DriverNestedInTrip] = None     
    
    class Config:
        from_attributes = True


##################################################################################################################

class VehicleTransmissionBase(BaseModel):
    vehicle_transmission: str

class VehicleTransmissionCreate(VehicleTransmissionBase):
    pass

class VehicleTransmissionOut(VehicleTransmissionBase):
    id: int

    class Config:
        from_attributes = True
##################################################################################################################


class VehicleTypeBase(BaseModel):
    vehicle_type: str

class VehicleTypeCreate(VehicleTypeBase):
    pass

class VehicleTypeOut(VehicleTypeBase):
    id: int

    class Config:
        from_attributes = True
##################################################################################################################

class VehicleMakeBase(BaseModel):
    vehicle_make: str

class VehicleMakeCreate(VehicleMakeBase):
    pass

class VehicleMakeOut(VehicleMakeBase):
    id: int

    class Config:
        from_attributes = True
##################################################################################################################

class VehicleModelBase(BaseModel):
    vehicle_model: str

class VehicleModelCreate(VehicleModelBase):
    pass

class VehicleModelOut(VehicleModelBase):
    id: int

    class Config:
        from_attributes = True
##################################################################################################################
# --- Vehicle Schemas ---
class VehicleBase(BaseModel):
    make: int # This is the ID of the vehicle_make
    model: int # This is the ID of the vehicle_model
    year: int
    plate_number: str
    mileage: float = 0.0
    engine_size: float
    vehicle_type: int # This is the ID of the vehicle_type
    vehicle_transmission: int # ID
    vehicle_fuel_type: int # ID
    vin: str
    color: str
    purchase_price: float
    purchase_date: Optional[datetime] = None
    status: str = "available"

class VehicleCreate(VehicleBase):
    pass

class VehicleOut(VehicleBase):
    id: int
    registration_date: datetime

    class Config:
        from_attributes = True

class VehicleSimpleOut(BaseModel):
    """
    A minimal vehicle representation for nesting in other schemas.
    Shows the most important identifying information.
    """
    id: int
    plate_number: str
    # You can add make/model names here if you create schemas for them
    # For now, we will rely on router logic to populate them if needed.

    class Config:
        from_attributes = True


##################################################################################################################
""" class RequestStatusEnum(str, enum.Enum):
    PENDING = "pending"
    APPROVED_BY_CHEF = "approved_by_chef"
    APPROVED_BY_LOGISTIC = "approved_by_logistic"
    APPROVED = "approved"
    DENIED = "denied"
    COMPLETED = "completed" """

########################################################################################################################
# --- Vehicle Request & Approval Schemas ---

class RequestApprovalOut(BaseModel):
    """
    Represents a single approval step in a response.
    """
    id: int
    approval_step: int
    status: str
    comments: Optional[str] = None
    approver: Optional[UserSimpleOut] = None # Nested user object for the approver
    updated_at: Optional[datetime] = None

    class Config:
        from_attributes = True

class VehicleRequestCreate(BaseModel):
    purpose: str = Field(..., min_length=5, max_length=255)
    from_location: str
    to_location: str
    departure_time: datetime
    return_time: datetime
    vehicle_id: Optional[int] = None 
    driver_id: Optional[int] = None 

class VehicleRequestUpdate(BaseModel):
    """
    Schema for updating a request's assignments, typically by an admin.
    All fields are optional, so an admin can update just one if needed.
    """
    vehicle_id: Optional[int] = None
    driver_id: Optional[int] = None

    class Config:
        from_attributes = True

class RequestApprovalUpdate(BaseModel):
    """
    Schema for submitting an approval decision.
    """
    status: str  # This should be validated as 'approved' or 'denied' in the router.
    comments: Optional[str] = None

    class Config:
        from_attributes = True

class VehicleRequestOut(BaseModel):
    """
    The full representation of a vehicle request returned by the API.
    It includes nested objects for related data for a rich response.
    """
    id: int
    purpose: str
    from_location: str
    to_location: str
    roadmap: Optional[str] = None
    departure_time: datetime
    return_time: datetime
    status: str
    created_at: datetime
    
    # --- Nested Objects for Richer API Responses ---
    requester: Optional[UserOut] = None
    vehicle: Optional[VehicleOut] = None
    driver: Optional[UserOut] = None # Uses UserSimpleOut for the driver
    
    approvals: List[RequestApprovalOut] = []

    class Config:
        from_attributes = True

##################################################################################################################
# In your schemas.py file, add this new class:

class VehicleStatusUpdate(BaseModel):
    status: str = Field(..., description="The new status for the vehicle (e.g., available, hors_service, in_mission)")


########################################################################################################################

##################################################################################################################

class GarageBase(BaseModel):
    nom_garage: str

class GarageCreate(GarageBase):
    pass

class GarageOut(GarageBase):
    id: int

    class Config:
        from_attributes = True
##################################################################################################################

class CategoryMaintenanceBase(BaseModel):
    cat_maintenance: str

class CategoryMaintenanceCreate(CategoryMaintenanceBase):
    pass

class CategoryMaintenanceOut(CategoryMaintenanceBase):
    id: int

    class Config:
        from_attributes = True
##################################################################################################################

# --- Maintenance Schemas ---
class MaintenanceBase(BaseModel):
    cat_maintenance_id: Optional[int] = None # Made optional to align with nullable=True in DB if that's the case
    vehicle_id: int
    garage_id: Optional[int] = None # Made optional to align with nullable=True in DB if that's the case
    maintenance_cost: float
    receipt: str
    maintenance_date: datetime
    status: str = Field(default="active", max_length=50, description="Status of maintenance (e.g., active, completed)")


class MaintenanceUpdate(BaseModel): # For partial updates, all fields should be optional
    cat_maintenance_id: Optional[int] = None # Made optional to align with nullable=True in DB if that's the case
    vehicle_id: int
    garage_id: Optional[int] = None # Made optional to align with nullable=True in DB if that's the case
    maintenance_cost: float
    receipt: str
    maintenance_date: datetime
    status: str = Field(default="active", max_length=50, description="Status of maintenance (e.g., active, completed)")

class MaintenanceCreate(MaintenanceBase):
    pass # No changes needed here, it inherits the corrected fields

class MaintenanceOut(MaintenanceBase):
    id: int
    created_at: datetime

    # Optional: Add fields from related models if you want to include them in the output
    # This requires using relationship loading in your API endpoint and defining nested Pydantic models.
    # Example:
    # vehicle_plate_number: Optional[str] = None
    # category_name: Optional[str] = None
    # garage_name: Optional[str] = None

    class Config:
        from_attributes = True # Was orm_mode = True in Pydantic V1
##################################################################################################################

class CategoryPanneBase(BaseModel):
    panne_name: str

class CategoryPanneCreate(CategoryPanneBase):
    pass

class CategoryPanneOut(CategoryPanneBase):
    id: int

    class Config:
        from_attributes = True
##################################################################################################################

# --- Panne Schemas ---
class PanneBase(BaseModel):
    vehicle_id: int = Field(..., gt=0, description="ID of the associated vehicle")
    category_panne_id: int = Field(..., gt=0, description="ID of the panne category")
    description: Optional[str] = Field(None, max_length=500, description="Detailed description of the panne")
    status: str = Field(default="active", max_length=50, description="Status of the panne (e.g., active, in_progress, resolved)")
    panne_date: datetime = Field(..., description="Date and time when the panne occurred or was reported")

class PanneCreate(PanneBase):
    pass # Inherits all fields and their validation from PanneBase

class PanneUpdate(BaseModel): # For partial updates, all fields should be optional
    vehicle_id: Optional[int] = Field(None, gt=0)
    category_panne_id: Optional[int] = Field(None, gt=0)
    description: Optional[str] = Field(None, max_length=500)
    status: Optional[str] = Field(None, max_length=50)
    panne_date: Optional[datetime] = None

class PanneOut(PanneBase):
    id: int
    created_at: datetime
    vehicle: Optional[VehicleOut] = None       # To hold related vehicle data
    category_panne: Optional[CategoryPanneOut] = None # To hold related category data

    class Config:
        from_attributes = True

# Schema for paginated response (useful for frontend)
class PaginatedPanneOut(BaseModel):
    total_count: int
    items: List[PanneOut]
##################################################################################################################

class ReparationStatusEnum(str, Enum):
    IN_PROGRESS = "Inprogress"
    COMPLETED = "Completed"

class ReparationBase(BaseModel):
    panne_id: int
    cost: Optional[float] = Field(default=0.0)
    receipt: str
    garage_id: int
    repair_date: datetime
    status: Optional[ReparationStatusEnum] = ReparationStatusEnum.IN_PROGRESS

class ReparationCreate(ReparationBase):
    pass

class ReparationUpdate(BaseModel):
    panne_id: Optional[int] = None
    cost: Optional[float] = None
    receipt: Optional[str] = None
    garage_id: Optional[int] = None
    repair_date: Optional[datetime] = None
    status: Optional[ReparationStatusEnum] = None


# In your schemas.py
class PanneOutForReparation(BaseModel): # A minimal schema for Panne
    id: int
    description: Optional[str] = None
    # ... other fields you want from Panne ...
    class Config:
        from_attributes = True

class GarageOutForReparation(BaseModel): # A minimal schema for Garage
    id: int
    nom_garage: Optional[str] = None # Or 'name'
    # ... other fields you want from Garage ...
    class Config:
        from_attributes = True

class ReparationResponse(ReparationBase): # Your existing base
    id: int
    panne: Optional[PanneOutForReparation] = None   # Add this
    garage: Optional[GarageOutForReparation] = None # Add this

    class Config:
        from_attributes = True



# Add these to your analytics_api.py, likely near other Pydantic models


# --- Pydantic Schemas for Analytics API ---
class MonthlyExpenseItem(BaseModel):
    month_year: str  # e.g., "Jan '23"
    fuel_cost: float = 0.0
    reparation_cost: float = 0.0
    maintenance_cost: float = 0.0
    purchase_cost: float = 0.0

class AnalyticsExpenseSummaryResponse(BaseModel):
    total_fuel_cost: float
    total_reparation_cost: float
    total_maintenance_cost: float
    total_vehicle_purchase_cost: float
    monthly_breakdown: List[MonthlyExpenseItem]
    # You could add other overall metrics here if needed, e.g., cost_per_mile for the period



# --- Pydantic Schemas for Analytics API ---

# --- Schemas for /expense-summary endpoint ---
class MonthlyExpenseItem(BaseModel):
    month_year: str
    fuel_cost: float = 0.0
    reparation_cost: float = 0.0
    maintenance_cost: float = 0.0
    purchase_cost: float = 0.0

class AnalyticsExpenseSummaryResponse(BaseModel):
    total_fuel_cost: float
    total_reparation_cost: float
    total_maintenance_cost: float
    total_vehicle_purchase_cost: float
    monthly_breakdown: List[MonthlyExpenseItem]

    

# --- Schemas for /detailed-expense-records endpoint ---
class FuelRecordDetail(BaseModel):
    id: int
    vehicle_plate: Optional[str] = "N/A"
    date: datetime # This is the log entry time, so datetime is appropriate
    quantity: float
    cost: float
    notes: Optional[str] = None

    class Config:
        #orm_mode = True
        from_attributes = True

class ReparationRecordDetail(BaseModel):
    id: int
    vehicle_plate: Optional[str] = "N/A"
    repair_date: date # Repair usually happens on a specific date
    description: str
    cost: float
    provider: Optional[str] = None

    class Config:
        #orm_mode = True
        from_attributes = True

class MaintenanceRecordDetail(BaseModel):
    id: int
    vehicle_plate: Optional[str] = "N/A"
    maintenance_date: date # Maintenance usually on a specific date
    description: str
    maintenance_cost: float
    provider: Optional[str] = None

    class Config:
        #orm_mode = True
        from_attributes = True

class PurchaseRecordDetail(BaseModel):
    id: int # Vehicle ID
    plate_number: str
    make: Optional[str] = "N/A"
    model: Optional[str] = "N/A"
    purchase_date: Optional[date] = None # Purchase on a specific date
    purchase_price: Optional[float] = 0.0

    class Config:
        #orm_mode = True
        from_attributes = True

class DetailedReportDataResponse(BaseModel):
    fuel_records: List[FuelRecordDetail] = []
    reparation_records: List[ReparationRecordDetail] = []
    maintenance_records: List[MaintenanceRecordDetail] = []
    purchase_records: List[PurchaseRecordDetail] = []
    

# =================================================================
# === ADDED SCHEMAS TO FIX THE "RequestOut" ERROR ===
# =================================================================

class RequestBase(BaseModel):
    # These fields seem appropriate for a generic request model
    # based on your `request.py` router.
    purpose:str
    from_location:str
    to_location:str
    departure_time: datetime
    return_time: datetime
    

class RequestCreate(RequestBase):
    # This is what the user sends to create a request.
    pass

class RequestOut(RequestBase):
    # This is the response model that was missing.
    id: int
    status: str
    created_at: datetime
    user: UserOut  # Nested schema to show who created the request
    approvals: List[RequestApprovalOut] = [] # Use the existing approval schema

    class Config:
        from_attributes = True



class PendingRequestsCount(BaseModel):
    count: int


class VehicleRequestAssignmentUpdate(BaseModel):
    vehicle_id: Optional[int] = None
    driver_id: Optional[int] = None




class RequesterOut(BaseModel):
    """
    A specific user representation for vehicle requests, which includes
    the user's service/department details.
    """
    id: int
    first_name: str
    last_name: str
    matricule: str
    user: UserOut
    #service: Optional[ServiceOut] = None # The nested service object

    class Config:
        from_attributes = True
